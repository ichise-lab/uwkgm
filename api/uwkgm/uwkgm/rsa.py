"""RSA keys manager

UWKGM platform uses RSA for JWT-based authentication and authorization.
The keys are automatically generated by default according to JWT configuration in the project's settings.

The UWKGM project
:copyright: (c) 2020 Ichise Laboratory at NII & AIST
:author: Rungsiman Nararatwong
"""

import os
import random
import string

from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa


KEYS_DIR = '%s/../private/keys/rsa' % os.path.dirname(os.path.realpath(__file__))
PASSWORD_FILE_PATH = '%s/password.bin' % KEYS_DIR
PRIVATE_KEY_FILE = '%s/private.pem' % KEYS_DIR
PUBLIC_KEY_FILE = '%s/public.pem' % KEYS_DIR

if not os.path.exists(KEYS_DIR):
    os.makedirs(KEYS_DIR)


def gen_random_string(length: int) -> str:
    """Password generator"""

    pool = string.ascii_letters + string.digits
    return ''.join(random.choice(pool) for _ in range(length))


def save_password(password: bytes) -> None:
    with open(PASSWORD_FILE_PATH, 'wb') as file:
        file.write(bytes(password))


def load_password() -> bytes:
    if os.path.exists(PASSWORD_FILE_PATH):
        with open(PASSWORD_FILE_PATH, 'rb') as file:
            return file.read()

    else:
        password = bytes(gen_random_string(10), encoding='utf-8')

        with open(PASSWORD_FILE_PATH, 'wb') as file:
            file.write(password)

        return password


def gen_keys(password: str = None) -> None:
    """Generate and save private and public keys"""

    if password is None:
        password = load_password()

    key = rsa.generate_private_key(public_exponent=65537,
                                   key_size=2048,
                                   backend=default_backend())

    with open(PRIVATE_KEY_FILE, 'wb') as file:
        private_key = key.private_bytes(encoding=serialization.Encoding.PEM,
                                        format=serialization.PrivateFormat.PKCS8,
                                        encryption_algorithm=serialization.BestAvailableEncryption(bytes(password)))
        file.write(private_key)

    with open(PUBLIC_KEY_FILE, 'wb') as file:
        public_key = key.public_key().public_bytes(encoding=serialization.Encoding.PEM,
                                                   format=serialization.PublicFormat.SubjectPublicKeyInfo)

        file.write(public_key)


def get_private_key(password: str = None) -> bytes:
    """Get existing private key using the given password. If the key does not exist, generate a new key using
    the given or randomly generated password"""

    if password is None:
        password = load_password()

    if not os.path.exists(PRIVATE_KEY_FILE):
        gen_keys(password)

    with open(PRIVATE_KEY_FILE, 'rb') as f:
        return serialization.load_pem_private_key(f.read(),
                                                  password=bytes(password),
                                                  backend=default_backend())


def get_public_key() -> bytes:
    with open(PUBLIC_KEY_FILE, 'rb') as f:
        return serialization.load_pem_public_key(f.read(),
                                                 backend=default_backend())


def clear_keys() -> None:
    if os.path.exists(PRIVATE_KEY_FILE):
        os.remove(PRIVATE_KEY_FILE)

    if os.path.exists(PUBLIC_KEY_FILE):
        os.remove(PUBLIC_KEY_FILE)

    if os.path.exists(PASSWORD_FILE_PATH):
        os.remove(PASSWORD_FILE_PATH)
